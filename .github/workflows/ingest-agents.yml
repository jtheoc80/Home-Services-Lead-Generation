
name: Ingest Agents (Austin/Dallas)

on:
  # Manual trigger
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run mode (no actual data insertion)'
        required: false
        default: 'false'
        type: boolean
  
  # Scheduled trigger (every 6 hours)
  schedule:
    - cron: "0 */6 * * *"   # every 6 hours

env:
  VERCEL_DOMAIN: ${{ secrets.VERCEL_DOMAIN }}
  CRON_SECRET: ${{ secrets.CRON_SECRET }}

jobs:
  ingest:
    runs-on: [self-hosted, linux, x64, scrape]
    
    concurrency:
      group: ${{ github.workflow }}-${{ matrix.source }}-${{ github.ref }}
      cancel-in-progress: true

    timeout-minutes: 30
    
    strategy:
      fail-fast: false
      max-parallel: 2
      matrix:
        source: [austin, dallas, houston, san_antonio]
    
    steps:
    - name: Create output directories
      run: |
        mkdir -p logs artifacts
        
    - name: "Preflight: verify required secrets"
      id: preflight
      shell: bash
      env:
        VERCEL_DOMAIN: ${{ secrets.VERCEL_DOMAIN }}
        CRON_SECRET: ${{ secrets.CRON_SECRET }}
      run: |
        ok=1
        for v in VERCEL_DOMAIN CRON_SECRET; do
          val="${!v}"
          if [ -z "$val" ]; then
            echo "::error title=$v missing::Set $v in GitHub → Settings → Secrets and variables → Actions"
            ok=0
          else
            echo "::add-mask::$val"
          fi
        done
        echo "ok=$ok" >> "$GITHUB_OUTPUT"
        [ "$ok" -eq 1 ]
        
    - name: Trigger permit ingestion for ${{ matrix.source }}
      id: ingest
      env:
        VERCEL_DOMAIN: ${{ secrets.VERCEL_DOMAIN }}
        CRON_SECRET: ${{ secrets.CRON_SECRET }}
      run: |
        SOURCE="${{ matrix.source }}"
        DRY_RUN="${{ inputs.dry_run }}"
        [ -z "$DRY_RUN" ] && DRY_RUN="false"
        
        echo "🚀 Triggering permit ingestion for source: $SOURCE" | tee -a logs/etl_output.log
        echo "🧪 Dry run mode: $DRY_RUN" | tee -a logs/etl_output.log
        echo "📡 Target: https://$VERCEL_DOMAIN/api/permits/permits/ingest" | tee -a logs/etl_output.log
        
        # Prepare URL with query parameters
        URL="https://$VERCEL_DOMAIN/api/permits/permits/ingest?source=$SOURCE"
        if [ "$DRY_RUN" == "true" ]; then
          URL="$URL&dry=1"
        fi
        
        echo "📞 Making request to: $URL" | tee -a logs/etl_output.log
        
        # Make the API call to the permits ingest endpoint
        RESPONSE=$(curl -s -w "\n%{http_code}" \
          -X POST \
          -H "Content-Type: application/json" \
          -H "x-cron-secret: $CRON_SECRET" \
          "$URL")
        
        # Extract status code from response
        HTTP_STATUS=$(echo "$RESPONSE" | tail -n1)
        RESPONSE_BODY=$(echo "$RESPONSE" | head -n -1)
        
        echo "📊 HTTP Status: $HTTP_STATUS" | tee -a logs/etl_output.log
        echo "📋 Response:" | tee -a logs/etl_output.log
        echo "$RESPONSE_BODY" | jq '.' 2>/dev/null | tee -a logs/etl_output.log || echo "$RESPONSE_BODY" | tee -a logs/etl_output.log
        
        # Check if successful
        if [ "$HTTP_STATUS" -eq 200 ]; then
          echo "✅ Permit ingestion completed successfully for $SOURCE"
          
          # Extract summary information if available
          FETCHED=$(echo "$RESPONSE_BODY" | jq -r '.fetched // "N/A"' 2>/dev/null)
          UPSERTS=$(echo "$RESPONSE_BODY" | jq -r '.upserts // "N/A"' 2>/dev/null)
          BEFORE_COUNT=$(echo "$RESPONSE_BODY" | jq -r '.beforeCount // "N/A"' 2>/dev/null)
          AFTER_COUNT=$(echo "$RESPONSE_BODY" | jq -r '.afterCount // "N/A"' 2>/dev/null)
          ERRORS=$(echo "$RESPONSE_BODY" | jq -r '.errors | length // 0' 2>/dev/null)
          
          echo "summary_fetched=$FETCHED" >> $GITHUB_OUTPUT
          echo "summary_upserts=$UPSERTS" >> $GITHUB_OUTPUT
          echo "summary_before_count=$BEFORE_COUNT" >> $GITHUB_OUTPUT
          echo "summary_after_count=$AFTER_COUNT" >> $GITHUB_OUTPUT
          echo "summary_errors=$ERRORS" >> $GITHUB_OUTPUT
          echo "success=true" >> $GITHUB_OUTPUT
        else
          echo "❌ Permit ingestion failed for $SOURCE with status: $HTTP_STATUS"
          echo "success=false" >> $GITHUB_OUTPUT
          exit 1
        fi
      
    - name: Step Summary for ${{ matrix.source }}
      if: always()
      run: |
        # Determine status with shell conditional
        if [ "${{ steps.ingest.outputs.success }}" == "true" ]; then
          STATUS="✅ Success"
        else
          STATUS="❌ Failed"
        fi
        
        # Build dry run value with shell default
        DRY_RUN="${{ inputs.dry_run }}"
        [ -z "$DRY_RUN" ] && DRY_RUN="false"
        
        echo "## Ingest Summary: ${{ matrix.source }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Source**: ${{ matrix.source }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Trigger**: ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Dry Run**: $DRY_RUN" >> $GITHUB_STEP_SUMMARY
        echo "- **Status**: $STATUS" >> $GITHUB_STEP_SUMMARY
        
        if [ "${{ steps.ingest.outputs.success }}" == "true" ]; then
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Results" >> $GITHUB_STEP_SUMMARY
          echo "- **Fetched**: ${{ steps.ingest.outputs.summary_fetched }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Upserts**: ${{ steps.ingest.outputs.summary_upserts }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Before Count**: ${{ steps.ingest.outputs.summary_before_count }}" >> $GITHUB_STEP_SUMMARY
          echo "- **After Count**: ${{ steps.ingest.outputs.summary_after_count }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Errors**: ${{ steps.ingest.outputs.summary_errors }}" >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "🔗 [View workflow run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})" >> $GITHUB_STEP_SUMMARY

    - name: Upload ETL logs (always)
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: etl-logs-${{ github.job }}-${{ github.run_id }}
        path: |
          logs/**/*.log
          artifacts/**/*
        if-no-files-found: warn

